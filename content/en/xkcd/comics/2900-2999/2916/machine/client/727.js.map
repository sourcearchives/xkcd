{"version":3,"file":"727.js","mappings":"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","sources":["webpack://incredible/./node_modules/@dimforge/rapier2d/coarena.js","webpack://incredible/./node_modules/@dimforge/rapier2d/control/character_controller.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/island_manager.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js","webpack://incredible/./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js","webpack://incredible/./node_modules/@dimforge/rapier2d/exports.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/broad_phase.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/collider.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/collider_set.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/contact.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/feature.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/point.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/ray.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/shape.js","webpack://incredible/./node_modules/@dimforge/rapier2d/geometry/toi.js","webpack://incredible/./node_modules/@dimforge/rapier2d/math.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/event_queue.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js","webpack://incredible/./node_modules/@dimforge/rapier2d/pipeline/world.js","webpack://incredible/./node_modules/@dimforge/rapier2d/rapier.js","webpack://incredible/./node_modules/@dimforge/rapier2d/rapier_wasm2d.js","webpack://incredible/./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js"],"sourcesContent":["export class Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map","import { RawKinematicCharacterController, RawCharacterCollision } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    setUp(vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(c.translationDeltaApplied());\n            out.translationDeltaRemaining = VectorOps.fromRaw(c.translationDeltaRemaining());\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map","import { RawCCDSolver } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport var CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawGenericJoint, RawJointAxis, RawJointType, } from \"../raw\";\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport var JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n    JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n})(JointType || (JointType = {}));\nexport var MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.X || JointAxesMask.Y\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport var JointAxesMask;\n(function (JointAxesMask) {\n    JointAxesMask[JointAxesMask[\"X\"] = 1] = \"X\";\n    JointAxesMask[JointAxesMask[\"Y\"] = 2] = \"Y\";\n    JointAxesMask[JointAxesMask[\"Z\"] = 4] = \"Z\";\n    JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n    JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n    JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nexport class ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nexport class FixedImpulseJoint extends ImpulseJoint {\n}\nexport class RopeImpulseJoint extends ImpulseJoint {\n}\nexport class SpringImpulseJoint extends ImpulseJoint {\n}\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\nexport class JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n    static rope(length, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n    // #if DIM2\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static revolute(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM2\n                result = RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM2\n            case JointType.Revolute:\n                result = RawGenericJoint.revolute(rawA1, rawA2);\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map","import { RawImpulseJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { ImpulseJoint, } from \"./impulse_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map","import { RawIntegrationParameters } from \"../raw\";\nexport class IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp() {\n        return this.raw.erp;\n    }\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError() {\n        return this.raw.allowedLinearError;\n    }\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance() {\n        return this.raw.predictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set erp(value) {\n        this.raw.erp = value;\n    }\n    set allowedLinearError(value) {\n        this.raw.allowedLinearError = value;\n    }\n    set predictionDistance(value) {\n        this.raw.predictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value) {\n        this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value) {\n        this.raw.numInternalPgsIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n    switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n    switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map","import { RawIslandManager } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    constructor(raw) {\n        this.raw = raw || new RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map","import { RawJointAxis, RawJointType, } from \"../raw\";\nexport class MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitMultibodyJoint extends MultibodyJoint {\n}\nexport class FixedMultibodyJoint extends MultibodyJoint {\n}\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n//# sourceMappingURL=multibody_joint.js.map","import { RawMultibodyJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { MultibodyJoint, } from \"./multibody_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map","import { RotationOps, VectorOps } from \"../math\";\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport var RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, wakeUp) {\n        this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    additionalSolverIterations() {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM2\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(angle, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM2\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n    setNextKinematicRotation(angle) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return this.rawSet.rbAngvel(this.handle);\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, wakeUp) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, principalAngularInertia, wakeUp);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\nexport class RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM2\n        this.angvel = 0.0;\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n    setLinvel(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        this.angvel = vel;\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.restrictTranslations(false, false);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        this.rotationsEnabled = false;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map","import { RawRigidBodySet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { VectorOps, RotationOps } from \"../math\";\nimport { RigidBody, } from \"./rigid_body\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM2\n        desc.angvel, desc.principalAngularInertia, desc.translationsEnabledX, desc.translationsEnabledY, desc.rotationsEnabled, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map","import { version as vers } from \"./raw\";\nexport function version() {\n    return vers();\n}\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n//# sourceMappingURL=exports.js.map","import { RawBroadPhase } from \"../raw\";\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map","import { RotationOps, VectorOps } from \"../math\";\nimport { CoefficientCombineRule, } from \"../dynamics\";\nimport { ActiveHooks, ActiveEvents } from \"../pipeline\";\nimport { Shape, Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, HalfSpace, \n// #if DIM2\nConvexPolygon, RoundConvexPolygon,\n// #endif\n } from \"./shape\";\nimport { RayIntersection } from \"./ray\";\nimport { PointProjection } from \"./point\";\nimport { ShapeColliderTOI, ShapeTOI } from \"./toi\";\nimport { ShapeContact } from \"./contact\";\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport var ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, principalAngularInertia);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotation(angle) {\n        this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotationWrtParent(angle) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n        let result = ShapeColliderTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nexport var MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nexport class ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        // #if DIM2\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices) {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n    static cuboid(hx, hy) {\n        const shape = new Cuboid(hx, hy);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, borderRadius) {\n        const shape = new RoundCuboid(hx, hy, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    static halfspace(normal) {\n        const shape = new HalfSpace(normal);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(heights, scale) {\n        const shape = new Heightfield(heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new ConvexPolygon(points, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexPolyline(vertices) {\n        const shape = new ConvexPolygon(vertices, true);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new RoundConvexPolygon(points, borderRadius, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const shape = new RoundConvexPolygon(vertices, borderRadius, true);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The principal angular inertia of the collider to create.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map","import { RawColliderSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { RotationOps, VectorOps } from \"../math\";\nimport { Collider } from \"./collider\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM2\n        desc.principalAngularInertia, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map","import { VectorOps } from \"../math\";\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), VectorOps.fromRaw(raw.point1()), VectorOps.fromRaw(raw.point2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map","// #if DIM2\nexport var FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Face\"] = 1] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 2] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map","import { RawNarrowPhase } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nexport class TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    normal() {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM2\n    contactTangentImpulse(i) {\n        return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    constructor(toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    constructor(collider, toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    constructor(collider, toi) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderToi(colliderSet.get(raw.colliderHandle()), raw.toi());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawShape, RawShapeType } from \"../raw\";\nimport { ShapeContact } from \"./contact\";\nimport { PointProjection } from \"./point\";\nimport { RayIntersection } from \"./ray\";\nimport { ShapeTOI } from \"./toi\";\nexport class Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM2\n                return new Cuboid(extents.x, extents.y);\n            // #endif\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundCuboid(extents.x, extents.y, borderRadius);\n            // #endif\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Segment(VectorOps.new(vs[0], vs[1]), VectorOps.new(vs[2], vs[3]));\n            // #endif\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Triangle(VectorOps.new(vs[0], vs[1]), VectorOps.new(vs[2], vs[3]), VectorOps.new(vs[4], vs[5]));\n            // #endif\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundTriangle(VectorOps.new(vs[0], vs[1]), VectorOps.new(vs[2], vs[3]), VectorOps.new(vs[4], vs[5]), borderRadius);\n            // #endif\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM2\n                return new Heightfield(heights, scale);\n            // #endif\n            // #if DIM2\n            case RawShapeType.ConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                return new ConvexPolygon(vs, false);\n            case RawShapeType.RoundConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolygon(vs, borderRadius, false);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stopAtPenetration) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolygon\"] = 9] = \"ConvexPolygon\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 10] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 11] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundConvexPolygon\"] = 12] = \"RoundConvexPolygon\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 13] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.ball(this.radius);\n    }\n}\nexport class HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     */\n    constructor(hx, hy) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = VectorOps.new(hx, hy);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = VectorOps.new(hx, hy);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.ConvexPolygon;\n        this.vertices = vertices;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return RawShape.convexPolyline(this.vertices);\n        }\n        else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param borderRadius - The radius of the borders of this convex polygon.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, borderRadius, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.RoundConvexPolygon;\n        this.vertices = vertices;\n        this.borderRadius = borderRadius;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return RawShape.roundConvexPolyline(this.vertices, this.borderRadius);\n        }\n        else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    constructor(heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map","import { VectorOps } from \"../math\";\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    constructor(toi, witness1, witness2, normal1, normal2) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeTOI(raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    constructor(collider, toi, witness1, witness2, normal1, normal2) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeColliderTOI(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map","import { RawVector, RawRotation } from \"./raw\";\n/**\n * A 2D vector.\n */\nexport class Vector2 {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport class VectorOps {\n    static new(x, y) {\n        return new Vector2(x, y);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y);\n        raw.free();\n        return res;\n    }\n    static intoRaw(v) {\n        return new RawVector(v.x, v.y);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n    }\n}\nexport class RotationOps {\n    static identity() {\n        return 0.0;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = raw.angle;\n        raw.free();\n        return res;\n    }\n    static intoRaw(angle) {\n        return RawRotation.fromAngle(angle);\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map","import { RawDebugRenderPipeline } from \"../raw\";\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map","import { RawEventQueue } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport var ActiveEvents;\n(function (ActiveEvents) {\n    ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map","export var ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nexport var SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map","import { RawPhysicsPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nexport class PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map","import { RawQueryPipeline } from \"../raw\";\nimport { PointColliderProjection, RayColliderIntersection, RayColliderToi, ShapeColliderTOI, } from \"../geometry\";\nimport { RotationOps, VectorOps } from \"../math\";\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport var QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(bodies, colliders) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map","import { RawSerializationPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nimport { World } from \"./world\";\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map","import { BroadPhase, ColliderSet, NarrowPhase, } from \"../geometry\";\nimport { CCDSolver, IntegrationParameters, IslandManager, ImpulseJointSet, MultibodyJointSet, RigidBodySet, } from \"../dynamics\";\nimport { VectorOps } from \"../math\";\nimport { PhysicsPipeline } from \"./physics_pipeline\";\nimport { QueryPipeline } from \"./query_pipeline\";\nimport { SerializationPipeline } from \"./serialization_pipeline\";\nimport { DebugRenderBuffers, DebugRenderPipeline } from \"./debug_render_pipeline\";\nimport { KinematicCharacterController } from \"../control\";\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map","import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n//# sourceMappingURL=rapier.js.map","import * as wasm from \"./rapier_wasm2d_bg.wasm\";\nimport { __wbg_set_wasm } from \"./rapier_wasm2d_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./rapier_wasm2d_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Face:1,\"1\":\"Face\",Unknown:2,\"2\":\"Unknown\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Rope:3,\"3\":\"Rope\",Spring:4,\"4\":\"Spring\",Generic:5,\"5\":\"Generic\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolygon:9,\"9\":\"ConvexPolygon\",RoundCuboid:10,\"10\":\"RoundCuboid\",RoundTriangle:11,\"11\":\"RoundTriangle\",RoundConvexPolygon:12,\"12\":\"RoundConvexPolygon\",HalfSpace:13,\"13\":\"HalfSpace\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",AngX:2,\"2\":\"AngX\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslation(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslationWrtParent(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * Sets the rotation angle of this collider.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotation(handle, angle) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotationWrtParent(handle, angle) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n    */\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawkinematiccharactercontroller_up(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n    * Sets the rotation angle of this rigid-body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, angle, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {number} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    rbSetNextKinematicTranslation(handle, x, y) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    rbSetNextKinematicRotation(handle, angle) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {number} angvel\n    * @param {number} principalAngularInertia\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} rotationsEnabled\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {RawRigidBodyType} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @param {number} additional_solver_iterations\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * The identity rotation.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The rotation with thegiven angle.\n    * @param {number} angle\n    * @returns {RawRotation}\n    */\n    static fromAngle(angle) {\n        const ret = wasm.rawrotation_fromAngle(angle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The imaginary part of this complex number.\n    * @returns {number}\n    */\n    get im() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The real part of this complex number.\n    * @returns {number}\n    */\n    get re() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The rotation angle in radians.\n    * @returns {number}\n    */\n    get angle() {\n        const ret = wasm.rawrotation_angle(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy) {\n        const ret = wasm.rawshape_cuboid(hx, hy);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @returns {RawShape | undefined}\n    */\n    static convexPolyline(vertices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexPolyline(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcontactforceevent_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawkinematiccharactercontroller_up(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecollidertoi_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 2D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 2D vector.\n    * - `y`: the `y` component of this 2D vector.\n    * @param {number} x\n    * @param {number} y\n    */\n    constructor(x, y) {\n        const ret = wasm.rawvector_new(x, y);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n    * @returns {RawVector}\n    */\n    xy() {\n        const ret = wasm.rawvector_xy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n    * @returns {RawVector}\n    */\n    yx() {\n        const ret = wasm.rawvector_yx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_4c92f6aec1e1d6e6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_776890ca77946e2f() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_60a9a80cada2f33c(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_69193e31c844b792(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_6146c51d49a2c0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_d7327c75a759af37(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_68d29ab115d0099c(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n"],"names":["Coarena","constructor","this","fconv","Float64Array","uconv","Uint32Array","buffer","data","Array","size","set","handle","i","index","length","push","len","clear","get","forEach","f","elt","getAll","filter","CharacterCollision","KinematicCharacterController","offset","params","bodies","colliders","queries","raw","rawCharacterCollision","_applyImpulsesToDynamicBodies","_characterMass","free","undefined","up","setUp","vector","rawVect","intoRaw","applyImpulsesToDynamicBodies","setApplyImpulsesToDynamicBodies","enabled","characterMass","setCharacterMass","mass","setOffset","value","slideEnabled","setSlideEnabled","autostepMaxHeight","autostepMinWidth","autostepIncludesDynamicBodies","autostepEnabled","enableAutostep","maxHeight","minWidth","includeDynamicBodies","disableAutostep","maxSlopeClimbAngle","setMaxSlopeClimbAngle","angle","minSlopeSlideAngle","setMinSlopeSlideAngle","snapToGroundDistance","enableSnapToGround","distance","disableSnapToGround","snapToGroundEnabled","computeColliderMovement","collider","desiredTranslationDelta","filterFlags","filterGroups","filterPredicate","rawTranslationDelta","dt","castClosure","computedMovement","fromRaw","computedGrounded","numComputedCollisions","computedCollision","out","c","translationDeltaApplied","translationDeltaRemaining","toi","witness1","worldWitness1","witness2","worldWitness2","normal1","worldNormal1","normal2","worldNormal2","CCDSolver","CoefficientCombineRule","JointType","MotorModel","JointAxesMask","ImpulseJoint","rawSet","bodySet","newTyped","jointType","Revolute","RevoluteImpulseJoint","Prismatic","PrismaticImpulseJoint","Fixed","FixedImpulseJoint","Spring","SpringImpulseJoint","Rope","RopeImpulseJoint","finalizeDeserialization","isValid","contains","body1","jointBodyHandle1","body2","jointBodyHandle2","type","anchor1","jointAnchor1","anchor2","jointAnchor2","setAnchor1","newPos","rawPoint","jointSetAnchor1","setAnchor2","jointSetAnchor2","setContactsEnabled","jointSetContactsEnabled","contactsEnabled","jointContactsEnabled","UnitImpulseJoint","limitsEnabled","jointLimitsEnabled","rawAxis","limitsMin","jointLimitsMin","limitsMax","jointLimitsMax","setLimits","min","max","jointSetLimits","configureMotorModel","model","jointConfigureMotorModel","configureMotorVelocity","targetVel","factor","jointConfigureMotorVelocity","configureMotorPosition","targetPos","stiffness","damping","jointConfigureMotorPosition","configureMotor","jointConfigureMotor","X","AngX","JointData","fixed","frame1","frame2","res","spring","rest_length","rope","revolute","prismatic","axis","rawAx","result","rawA1","rawA2","rawFra1","rawFra2","limits","ImpulseJointSet","map","forEachJointHandle","joint","createJoint","desc","parent1","parent2","wakeUp","rawParams","remove","unmap","forEachJointHandleAttachedToRigidBody","forEachJointAttachedToRigidBody","delete","IntegrationParameters","erp","allowedLinearError","predictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","switchToStandardPgsSolver","switchToSmallStepsPgsSolver","IslandManager","forEachActiveRigidBodyHandle","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","wake_up","RigidBodyType","RigidBody","colliderSet","lockTranslations","locked","rbLockTranslations","lockRotations","rbLockRotations","setEnabledTranslations","enableX","enableY","rbSetEnabledTranslations","restrictTranslations","dominanceGroup","rbDominanceGroup","setDominanceGroup","group","rbSetDominanceGroup","additionalSolverIterations","rbAdditionalSolverIterations","setAdditionalSolverIterations","iters","rbSetAdditionalSolverIterations","enableCcd","rbEnableCcd","translation","rbTranslation","rotation","rbRotation","nextTranslation","rbNextTranslation","nextRotation","rbNextRotation","setTranslation","tra","rbSetTranslation","x","y","setLinvel","vel","rawVel","rbSetLinvel","gravityScale","rbGravityScale","setGravityScale","rbSetGravityScale","setRotation","rbSetRotation","setAngvel","rbSetAngvel","setNextKinematicTranslation","t","rbSetNextKinematicTranslation","setNextKinematicRotation","rbSetNextKinematicRotation","linvel","rbLinvel","angvel","rbAngvel","rbMass","effectiveInvMass","rbEffectiveInvMass","invMass","rbInvMass","localCom","rbLocalCom","worldCom","rbWorldCom","invPrincipalInertiaSqrt","rbInvPrincipalInertiaSqrt","principalInertia","rbPrincipalInertia","effectiveWorldInvInertiaSqrt","rbEffectiveWorldInvInertiaSqrt","effectiveAngularInertia","rbEffectiveAngularInertia","sleep","rbSleep","rbWakeUp","isCcdEnabled","rbIsCcdEnabled","numColliders","rbNumColliders","rbCollider","setEnabled","rbSetEnabled","isEnabled","rbIsEnabled","bodyType","rbBodyType","setBodyType","rbSetBodyType","isSleeping","rbIsSleeping","isMoving","rbIsMoving","isFixed","rbIsFixed","isKinematic","rbIsKinematic","isDynamic","rbIsDynamic","linearDamping","rbLinearDamping","angularDamping","rbAngularDamping","setLinearDamping","rbSetLinearDamping","recomputeMassPropertiesFromColliders","rbRecomputeMassPropertiesFromColliders","setAdditionalMass","rbSetAdditionalMass","setAdditionalMassProperties","centerOfMass","principalAngularInertia","rawCom","rbSetAdditionalMassProperties","setAngularDamping","rbSetAngularDamping","resetForces","rbResetForces","resetTorques","rbResetTorques","addForce","force","rawForce","rbAddForce","applyImpulse","impulse","rawImpulse","rbApplyImpulse","addTorque","torque","rbAddTorque","applyTorqueImpulse","torqueImpulse","rbApplyTorqueImpulse","addForceAtPoint","point","rbAddForceAtPoint","applyImpulseAtPoint","rbApplyImpulseAtPoint","RigidBodyDesc","status","zeros","identity","massOnly","translationsEnabledX","translationsEnabledY","rotationsEnabled","canSleep","sleeping","ccdEnabled","dynamic","Dynamic","kinematicPositionBased","KinematicPositionBased","kinematicVelocityBased","KinematicVelocityBased","newDynamic","newKinematicPositionBased","newKinematicVelocityBased","newStatic","TypeError","rot","scale","copy","enabledTranslations","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","RigidBodySet","forEachRigidBodyHandle","rb","createRigidBody","rawTra","rawRot","rawLv","body","islands","impulseJoints","multibodyJoints","forEachActiveRigidBody","version","BroadPhase","ActiveCollisionTypes","MassPropsMode","Collider","parent","shape","_parent","_shape","coParent","ensureShapeIsCached","coTranslation","coRotation","isSensor","coIsSensor","setSensor","coSetSensor","setShape","rawShape","coSetShape","coSetEnabled","coIsEnabled","setRestitution","restitution","coSetRestitution","setFriction","friction","coSetFriction","frictionCombineRule","coFrictionCombineRule","setFrictionCombineRule","rule","coSetFrictionCombineRule","restitutionCombineRule","coRestitutionCombineRule","setRestitutionCombineRule","coSetRestitutionCombineRule","setCollisionGroups","groups","coSetCollisionGroups","setSolverGroups","coSetSolverGroups","activeHooks","coActiveHooks","setActiveHooks","coSetActiveHooks","activeEvents","coActiveEvents","setActiveEvents","coSetActiveEvents","activeCollisionTypes","coActiveCollisionTypes","setContactForceEventThreshold","threshold","coSetContactForceEventThreshold","contactForceEventThreshold","coContactForceEventThreshold","setActiveCollisionTypes","coSetActiveCollisionTypes","setDensity","density","coSetDensity","setMass","coSetMass","setMassProperties","coSetMassProperties","coSetTranslation","setTranslationWrtParent","coSetTranslationWrtParent","coSetRotation","setRotationWrtParent","coSetRotationWrtParent","shapeType","coShapeType","halfExtents","coHalfExtents","setHalfExtents","newHalfExtents","coSetHalfExtents","radius","coRadius","setRadius","newRadius","coSetRadius","roundRadius","coRoundRadius","setRoundRadius","newBorderRadius","coSetRoundRadius","halfHeight","coHalfHeight","setHalfHeight","newHalfheight","coSetHalfHeight","vertices","coVertices","indices","coIndices","heightfieldHeights","coHeightfieldHeights","heightfieldScale","coHeightfieldScale","coFriction","coRestitution","coDensity","coMass","volume","coVolume","collisionGroups","coCollisionGroups","solverGroups","coSolverGroups","containsPoint","coContainsPoint","projectPoint","solid","coProjectPoint","intersectsRay","ray","maxToi","rawOrig","origin","rawDir","dir","coIntersectsRay","castShape","collider1Vel","shape2","shape2Pos","shape2Rot","shape2Vel","stopAtPenetration","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","rawShape2","coCastShape","castCollider","collider2","collider2Vel","rawCollider2Vel","coCastCollider","intersectsShape","shapePos2","shapeRot2","rawPos2","rawRot2","coIntersectsShape","contactShape","prediction","coContactShape","contactCollider","coContactCollider","castRay","coCastRay","castRayAndGetNormal","coCastRayAndGetNormal","ColliderDesc","massPropsMode","Density","Average","DEFAULT","NONE","ball","capsule","segment","a","b","triangle","roundTriangle","borderRadius","polyline","trimesh","cuboid","hx","hy","roundCuboid","halfspace","normal","heightfield","heights","convexHull","points","convexPolyline","roundConvexHull","roundConvexPolyline","sensor","Mass","MassProps","ColliderSet","forEachColliderHandle","createCollider","parentHandle","hasParent","isNaN","Error","ShapeContact","dist","point1","point2","FeatureType","NarrowPhase","tempManifold","TempContactManifold","contactPairsWith","collider1","contact_pairs_with","intersectionPairsWith","intersection_pairs_with","contactPair","rawPair","contact_pair","flipped","numContactManifolds","contactManifold","intersectionPair","intersection_pair","localNormal1","local_n1","localNormal2","local_n2","subshape1","subshape2","numContacts","num_contacts","localContactPoint1","contact_local_p1","localContactPoint2","contact_local_p2","contactDist","contact_dist","contactFid1","contact_fid1","contactFid2","contact_fid2","contactImpulse","contact_impulse","contactTangentImpulse","contact_tangent_impulse","numSolverContacts","num_solver_contacts","solverContactPoint","solver_contact_point","solverContactDist","solver_contact_dist","solverContactFriction","solver_contact_friction","solverContactRestitution","solver_contact_restitution","solverContactTangentVelocity","solver_contact_tangent_velocity","PointProjection","isInside","PointColliderProjection","featureType","featureId","Unknown","colliderHandle","Ray","pointAt","RayIntersection","RayColliderIntersection","RayColliderToi","ShapeType","Shape","rawType","extents","vs","Ball","Cuboid","RoundCuboid","Capsule","Segment","new","Polyline","Triangle","RoundTriangle","HalfSpace","coHalfspaceNormal","TriMesh","HeightField","Heightfield","ConvexPolygon","RoundConvexPolygon","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawPos1","rawRot1","rawVel1","rawVel2","rawShape1","shapePos","shapeRot","rawPos","rawRayOrig","rawRayDir","super","n","ra","rc","skipConvexHullComputation","rawScale","ShapeTOI","ShapeColliderTOI","Vector2","VectorOps","v","input","RotationOps","fromAngle","DebugRenderBuffers","colors","DebugRenderPipeline","render","impulse_joints","multibody_joints","narrow_phase","ActiveEvents","TempContactForceEvent","totalForce","total_force","totalForceMagnitude","total_force_magnitude","maxForceDirection","max_force_direction","maxForceMagnitude","max_force_magnitude","EventQueue","autoDrain","drainCollisionEvents","drainContactForceEvents","event","ActiveHooks","SolverFlags","PhysicsPipeline","step","gravity","integrationParameters","broadPhase","narrowPhase","ccdSolver","eventQueue","hooks","rawG","stepWithEvents","filterContactPair","filterIntersectionPair","QueryFilterFlags","QueryPipeline","update","filterExcludeCollider","filterExcludeRigidBody","intersectionsWithRay","callback","rawInter","intersectionWithShape","projectPointAndGetFeature","intersectionsWithPoint","shapeVel","intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawCenter","rawHalfExtents","SerializationPipeline","serializeAll","rawGra","deserializeAll","World","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","queryPipeline","physicsPipeline","serializationPipeline","debugRenderPipeline","characterControllers","Set","controller","takeGravity","takeIntegrationParameters","takeIslandManager","takeBroadPhase","takeNarrowPhase","takeBodies","takeColliders","takeImpulseJoints","takeMultibodyJoints","takeSnapshot","restoreSnapshot","debugRender","propagateModifiedBodyPositionsToColliders","updateSceneQueries","timestep","niter","createCharacterController","add","removeCharacterController","createImpulseJoint","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","wasm","__wbg_set_wasm","val","heap","fill","heap_next","addHeapObject","obj","idx","getObject","takeObject","ret","dropObject","isLikeNone","cachedFloat64Memory0","getFloat64Memory0","byteLength","memory","cachedInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getStringFromWasm0","ptr","Uint8Array","subarray","deferred1_0","deferred1_1","retptr","__wbindgen_add_to_stack_pointer","r0","r1","__wbindgen_free","_assertClass","instance","klass","name","cachedFloat32Memory0","getFloat32Memory0","Float32Array","stack_pointer","addBorrowedObject","getArrayF32FromWasm0","cachedUint32Memory0","getUint32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","passArray32ToWasm0","handleError","args","apply","e","__wbindgen_exn_store","Object","freeze","Vertex","Face","RawJointType","Generic","RawShapeType","Compound","RawJointAxis","AccelerationBased","ForceBased","Y","RawBroadPhase","__wrap","create","prototype","__wbg_ptr","__destroy_into_raw","__wbg_rawbroadphase_free","rawbroadphase_new","RawCCDSolver","__wbg_rawccdsolver_free","rawccdsolver_new","RawCharacterCollision","__wbg_rawcharactercollision_free","rawcharactercollision_new","rawcharactercollision_handle","rawcharactercollision_translationDeltaApplied","RawVector","rawcharactercollision_translationDeltaRemaining","rawcharactercollision_toi","rawcharactercollision_worldWitness1","rawcharactercollision_worldWitness2","rawcharactercollision_worldNormal1","rawcharactercollision_worldNormal2","RawColliderSet","__wbg_rawcolliderset_free","rawcolliderset_coTranslation","rawcolliderset_coRotation","RawRotation","rawcolliderset_coSetTranslation","rawcolliderset_coSetTranslationWrtParent","rawcolliderset_coSetRotation","rawcolliderset_coSetRotationWrtParent","rawcolliderset_coIsSensor","rawcolliderset_coShapeType","rawcolliderset_coHalfspaceNormal","rawcolliderset_coHalfExtents","rawcolliderset_coSetHalfExtents","rawcolliderset_coRadius","rawcolliderset_coSetRadius","rawcolliderset_coHalfHeight","rawcolliderset_coSetHalfHeight","rawcolliderset_coRoundRadius","rawcolliderset_coSetRoundRadius","rawcolliderset_coVertices","v1","slice","rawcolliderset_coIndices","rawcolliderset_coHeightfieldHeights","rawcolliderset_coHeightfieldScale","rawcolliderset_coParent","r2","rawcolliderset_coSetEnabled","rawcolliderset_coIsEnabled","rawcolliderset_coFriction","rawcolliderset_coRestitution","rawcolliderset_coDensity","rawcolliderset_coMass","rawcolliderset_coVolume","rawcolliderset_coCollisionGroups","rawcolliderset_coSolverGroups","rawcolliderset_coActiveHooks","rawcolliderset_coActiveCollisionTypes","rawcolliderset_coActiveEvents","rawcolliderset_coContactForceEventThreshold","rawcolliderset_coContainsPoint","colliderVel","stop_at_penetration","RawShape","rawcolliderset_coCastShape","RawShapeTOI","collider2handle","max_toi","rawcolliderset_coCastCollider","RawShapeColliderTOI","rawcolliderset_coIntersectsShape","rawcolliderset_coContactShape","RawShapeContact","rawcolliderset_coContactCollider","rawcolliderset_coProjectPoint","RawPointProjection","rayOrig","rayDir","rawcolliderset_coIntersectsRay","rawcolliderset_coCastRay","rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","is_sensor","rawcolliderset_coSetSensor","rawcolliderset_coSetRestitution","rawcolliderset_coSetFriction","rawcolliderset_coFrictionCombineRule","rawcolliderset_coSetFrictionCombineRule","rawcolliderset_coRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","rawcolliderset_coSetCollisionGroups","rawcolliderset_coSetSolverGroups","rawcolliderset_coSetActiveHooks","events","rawcolliderset_coSetActiveEvents","types","rawcolliderset_coSetActiveCollisionTypes","rawcolliderset_coSetShape","rawcolliderset_coSetContactForceEventThreshold","rawcolliderset_coSetDensity","rawcolliderset_coSetMass","rawcolliderset_coSetMassProperties","rawcolliderset_new","rawcolliderset_len","rawcolliderset_contains","RawRigidBodySet","rawcolliderset_createCollider","RawIslandManager","rawcolliderset_remove","isHandleValid","rawcolliderset_forEachColliderHandle","RawContactForceEvent","__wbg_rawcontactforceevent_free","rawcontactforceevent_collider1","rawcontactforceevent_collider2","rawcontactforceevent_total_force","rawcontactforceevent_total_force_magnitude","rawcontactforceevent_max_force_magnitude","RawContactManifold","__wbg_rawcontactmanifold_free","rawcontactmanifold_normal","rawcontactmanifold_local_n1","rawcontactmanifold_local_n2","rawcontactmanifold_subshape1","rawcontactmanifold_subshape2","rawcontactmanifold_num_contacts","rawcontactmanifold_contact_local_p1","rawcontactmanifold_contact_local_p2","rawcontactmanifold_contact_dist","rawcontactmanifold_contact_fid1","rawcontactmanifold_contact_fid2","rawcontactmanifold_contact_impulse","rawcontactmanifold_contact_tangent_impulse","rawcontactmanifold_num_solver_contacts","rawcontactmanifold_solver_contact_point","rawcontactmanifold_solver_contact_dist","rawcontactmanifold_solver_contact_friction","rawcontactmanifold_solver_contact_restitution","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPair","__wbg_rawcontactpair_free","rawcontactpair_collider1","rawcontactpair_collider2","rawcontactpair_numContactManifolds","rawcontactpair_contactManifold","RawDebugRenderPipeline","__wbg_rawdebugrenderpipeline_free","rawdebugrenderpipeline_new","rawdebugrenderpipeline_vertices","rawdebugrenderpipeline_colors","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","rawdebugrenderpipeline_render","RawDeserializedWorld","__wbg_rawdeserializedworld_free","rawdeserializedworld_takeGravity","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","rawdeserializedworld_takeIslandManager","rawdeserializedworld_takeBroadPhase","rawdeserializedworld_takeNarrowPhase","rawdeserializedworld_takeBodies","rawdeserializedworld_takeColliders","rawdeserializedworld_takeImpulseJoints","rawdeserializedworld_takeMultibodyJoints","RawEventQueue","__wbg_raweventqueue_free","raweventqueue_new","raweventqueue_drainCollisionEvents","raweventqueue_drainContactForceEvents","raweventqueue_clear","RawGenericJoint","__wbg_rawgenericjoint_free","rawgenericjoint_spring","rawgenericjoint_rope","rawgenericjoint_prismatic","axes1","axes2","rawgenericjoint_fixed","rawgenericjoint_revolute","__wbg_rawimpulsejointset_free","rawimpulsejointset_jointType","rawimpulsejointset_jointBodyHandle1","rawimpulsejointset_jointBodyHandle2","jointFrameX1","rawimpulsejointset_jointFrameX1","jointFrameX2","rawimpulsejointset_jointFrameX2","rawimpulsejointset_jointAnchor1","rawimpulsejointset_jointAnchor2","rawimpulsejointset_jointSetAnchor1","rawimpulsejointset_jointSetAnchor2","rawimpulsejointset_jointContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","rawimpulsejointset_jointLimitsEnabled","rawimpulsejointset_jointLimitsMin","rawimpulsejointset_jointLimitsMax","rawimpulsejointset_jointSetLimits","rawimpulsejointset_jointConfigureMotorModel","rawimpulsejointset_jointConfigureMotorVelocity","rawimpulsejointset_jointConfigureMotorPosition","rawimpulsejointset_jointConfigureMotor","rawimpulsejointset_new","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","rawimpulsejointset_forEachJointHandle","rawimpulsejointset_forEachJointAttachedToRigidBody","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","rawintegrationparameters_dt","rawintegrationparameters_erp","rawintegrationparameters_allowedLinearError","rawintegrationparameters_numSolverIterations","rawintegrationparameters_numAdditionalFrictionIterations","rawintegrationparameters_numInternalPgsIterations","rawintegrationparameters_minIslandSize","rawintegrationparameters_maxCcdSubsteps","rawintegrationparameters_set_dt","rawintegrationparameters_set_erp","rawintegrationparameters_set_allowedLinearError","rawintegrationparameters_set_predictionDistance","rawintegrationparameters_set_numSolverIterations","rawintegrationparameters_set_numAdditionalFrictionIterations","rawintegrationparameters_set_numInternalPgsIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","rawintegrationparameters_switchToStandardPgsSolver","rawintegrationparameters_switchToSmallStepsPgsSolver","__wbg_rawislandmanager_free","rawislandmanager_new","rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterController","__wbg_rawkinematiccharactercontroller_free","rawkinematiccharactercontroller_new","rawkinematiccharactercontroller_up","rawkinematiccharactercontroller_setUp","rawkinematiccharactercontroller_setOffset","rawkinematiccharactercontroller_slideEnabled","rawkinematiccharactercontroller_setSlideEnabled","rawkinematiccharactercontroller_autostepMaxHeight","rawkinematiccharactercontroller_autostepMinWidth","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepEnabled","rawkinematiccharactercontroller_enableAutostep","rawkinematiccharactercontroller_disableAutostep","rawkinematiccharactercontroller_maxSlopeClimbAngle","rawkinematiccharactercontroller_setMaxSlopeClimbAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","rawkinematiccharactercontroller_snapToGroundDistance","rawkinematiccharactercontroller_enableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","rawkinematiccharactercontroller_snapToGroundEnabled","collider_handle","desired_translation_delta","apply_impulses_to_dynamic_bodies","character_mass","filter_flags","filter_groups","filter_predicate","RawQueryPipeline","rawkinematiccharactercontroller_computeColliderMovement","rawkinematiccharactercontroller_computedMovement","rawkinematiccharactercontroller_computedGrounded","rawkinematiccharactercontroller_numComputedCollisions","collision","rawkinematiccharactercontroller_computedCollision","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","__wbg_rawnarrowphase_free","rawnarrowphase_new","handle1","rawnarrowphase_contact_pairs_with","handle2","rawnarrowphase_contact_pair","rawnarrowphase_intersection_pairs_with","rawnarrowphase_intersection_pair","RawPhysicsPipeline","__wbg_rawphysicspipeline_free","rawphysicspipeline_new","joints","articulations","ccd_solver","rawphysicspipeline_step","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPointColliderProjection","__wbg_rawpointcolliderprojection_free","rawpointcolliderprojection_colliderHandle","rawpointcolliderprojection_point","rawpointcolliderprojection_isInside","rawpointcolliderprojection_featureType","rawpointcolliderprojection_featureId","__wbg_rawpointprojection_free","rawpointprojection_point","rawpointprojection_isInside","__wbg_rawquerypipeline_free","rawquerypipeline_new","rawquerypipeline_update","filter_exclude_collider","filter_exclude_rigid_body","rawquerypipeline_castRay","RawRayColliderToi","rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","rawquerypipeline_intersectionsWithRay","rawquerypipeline_intersectionWithShape","rawquerypipeline_projectPoint","rawquerypipeline_projectPointAndGetFeature","rawquerypipeline_intersectionsWithPoint","rawquerypipeline_castShape","rawquerypipeline_intersectionsWithShape","rawquerypipeline_collidersWithAabbIntersectingAabb","__wbg_rawraycolliderintersection_free","rawraycolliderintersection_normal","rawraycolliderintersection_toi","__wbg_rawraycollidertoi_free","__wbg_rawrayintersection_free","__wbg_rawrigidbodyset_free","rawrigidbodyset_rbTranslation","rawrigidbodyset_rbRotation","rawrigidbodyset_rbSleep","rawrigidbodyset_rbIsSleeping","rawrigidbodyset_rbIsMoving","rawrigidbodyset_rbNextTranslation","rawrigidbodyset_rbNextRotation","rawrigidbodyset_rbSetTranslation","rawrigidbodyset_rbSetRotation","rawrigidbodyset_rbSetLinvel","rawrigidbodyset_rbSetAngvel","rawrigidbodyset_rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicRotation","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMassProperties","rawrigidbodyset_rbLinvel","rawrigidbodyset_rbAngvel","rawrigidbodyset_rbLockTranslations","allow_x","allow_y","rawrigidbodyset_rbSetEnabledTranslations","rawrigidbodyset_rbLockRotations","rawrigidbodyset_rbDominanceGroup","rawrigidbodyset_rbSetDominanceGroup","rawrigidbodyset_rbEnableCcd","rawrigidbodyset_rbMass","rawrigidbodyset_rbInvMass","rawrigidbodyset_rbEffectiveInvMass","rawrigidbodyset_rbLocalCom","rawrigidbodyset_rbWorldCom","rawrigidbodyset_rbInvPrincipalInertiaSqrt","rawrigidbodyset_rbPrincipalInertia","rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","rawrigidbodyset_rbEffectiveAngularInertia","rawrigidbodyset_rbWakeUp","rawrigidbodyset_rbIsCcdEnabled","rawrigidbodyset_rbNumColliders","at","rawrigidbodyset_rbCollider","rawrigidbodyset_rbBodyType","rawrigidbodyset_rbSetBodyType","rawrigidbodyset_rbIsFixed","rawrigidbodyset_rbIsKinematic","rawrigidbodyset_rbIsDynamic","rawrigidbodyset_rbLinearDamping","rawrigidbodyset_rbAngularDamping","rawrigidbodyset_rbSetLinearDamping","rawrigidbodyset_rbSetAngularDamping","rawrigidbodyset_rbSetEnabled","rawrigidbodyset_rbIsEnabled","rawrigidbodyset_rbGravityScale","rawrigidbodyset_rbSetGravityScale","rawrigidbodyset_rbResetForces","rawrigidbodyset_rbResetTorques","rawrigidbodyset_rbAddForce","rawrigidbodyset_rbApplyImpulse","rawrigidbodyset_rbAddTorque","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rawrigidbodyset_rbAddForceAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rawrigidbodyset_rbAdditionalSolverIterations","rawrigidbodyset_rbSetAdditionalSolverIterations","rbUserData","rawrigidbodyset_rbUserData","rbSetUserData","rawrigidbodyset_rbSetUserData","rawrigidbodyset_new","translationEnabledX","translationEnabledY","rb_type","additional_solver_iterations","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_contains","rawrigidbodyset_forEachRigidBodyHandle","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","__wbg_rawrotation_free","rawrotation_identity","rawrotation_fromAngle","im","re","rawrotation_re","rawrotation_angle","RawSerializationPipeline","__wbg_rawserializationpipeline_free","rawserializationpipeline_new","rawserializationpipeline_serializeAll","rawserializationpipeline_deserializeAll","__wbg_rawshape_free","rawshape_cuboid","rawshape_roundCuboid","rawshape_ball","rawshape_halfspace","rawshape_capsule","ptr0","__wbindgen_malloc","len0","ptr1","len1","rawshape_polyline","rawshape_trimesh","rawshape_heightfield","p1","p2","rawshape_segment","p3","rawshape_triangle","rawshape_roundTriangle","rawshape_convexHull","rawshape_roundConvexHull","rawshape_convexPolyline","rawshape_roundConvexPolyline","rawshape_castShape","rawshape_intersectsShape","rawshape_contactShape","rawshape_containsPoint","rawshape_projectPoint","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","__wbg_rawshapecollidertoi_free","rawshapecollidertoi_witness2","rawshapecollidertoi_normal1","__wbg_rawshapecontact_free","__wbg_rawshapetoi_free","rawshapetoi_witness1","__wbg_rawvector_free","zero","rawvector_zero","rawvector_new","rawvector_set_x","xy","rawvector_xy","yx","rawvector_yx","__wbindgen_number_new","arg0","__wbindgen_boolean_get","__wbindgen_object_drop_ref","__wbindgen_number_get","arg1","__wbindgen_is_function","__wbg_rawraycolliderintersection_new","__wbg_rawcontactforceevent_new","__wbg_call_01734de55d61e11d","arg2","call","arguments","__wbg_call_4c92f6aec1e1d6e6","arg3","__wbg_call_776890ca77946e2f","arg4","__wbg_bind_60a9a80cada2f33c","bind","__wbg_buffer_085ec1f694018c4f","__wbg_newwithbyteoffsetandlength_6da8e527659b86aa","__wbg_new_8125e318e6245eed","__wbg_set_5cf90238115182c3","__wbg_length_72e2208bbc0efc61","__wbg_newwithbyteoffsetandlength_69193e31c844b792","__wbg_set_6146c51d49a2c0df","__wbg_length_d7327c75a759af37","__wbg_newwithlength_68d29ab115d0099c","__wbindgen_throw","__wbindgen_memory"],"sourceRoot":""}